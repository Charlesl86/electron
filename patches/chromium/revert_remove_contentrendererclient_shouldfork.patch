From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: deepak1556 <hop2deep@gmail.com>
Date: Wed, 23 Oct 2019 15:30:18 -0700
Subject: Revert "Remove ContentRendererClient::ShouldFork."

This reverts commit 6b068eb8ca4a3c7350bdafa22fc0cf0636ef8b74.

diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
index ca8ea8d93198c452ee3671c800d781b424985c16..dc56c19c18f5cab0f6a1ec31e32e7d6f432f6142 100644
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -1241,6 +1241,25 @@ bool ChromeContentRendererClient::AllowPopup() {
 #endif
 }
 
+bool ChromeContentRendererClient::ShouldFork(WebLocalFrame* frame,
+                                             const GURL& url,
+                                             const std::string& http_method,
+                                             bool is_initial_navigation,
+                                             bool is_server_redirect) {
+  DCHECK(!frame->Parent());
+
+  // If |url| matches one of the prerendered URLs, stop this navigation and try
+  // to swap in the prerendered page on the browser process. If the prerendered
+  // page no longer exists by the time the OpenURL IPC is handled, a normal
+  // navigation is attempted.
+  if (prerender_dispatcher_.get() &&
+      prerender_dispatcher_->IsPrerenderURL(url)) {
+    return true;
+  }
+
+  return false;
+}
+
 void ChromeContentRendererClient::WillSendRequest(
     WebLocalFrame* frame,
     ui::PageTransition transition_type,
diff --git a/chrome/renderer/chrome_content_renderer_client.h b/chrome/renderer/chrome_content_renderer_client.h
index ba4ff12b1bd3db7e54bdcb5c18b9c02f5523a2d2..6167ddb1faec8a2f2c9492ac0e434569f9957612 100644
--- a/chrome/renderer/chrome_content_renderer_client.h
+++ b/chrome/renderer/chrome_content_renderer_client.h
@@ -137,6 +137,11 @@ class ChromeContentRendererClient
       base::SingleThreadTaskRunner* compositor_thread_task_runner) override;
   bool RunIdleHandlerWhenWidgetsHidden() override;
   bool AllowPopup() override;
+  bool ShouldFork(blink::WebLocalFrame* frame,
+                  const GURL& url,
+                  const std::string& http_method,
+                  bool is_initial_navigation,
+                  bool is_server_redirect) override;
   void WillSendRequest(blink::WebLocalFrame* frame,
                        ui::PageTransition transition_type,
                        const blink::WebURL& url,
diff --git a/content/public/renderer/content_renderer_client.cc b/content/public/renderer/content_renderer_client.cc
index 36da488c6c307a20509c0eec1c71666da0212bdb..ee6f04482aa56bffc580381a06d2fdf51e5682d0 100644
--- a/content/public/renderer/content_renderer_client.cc
+++ b/content/public/renderer/content_renderer_client.cc
@@ -105,6 +105,14 @@ bool ContentRendererClient::HandleNavigation(
 }
 #endif
 
+bool ContentRendererClient::ShouldFork(blink::WebLocalFrame* frame,
+                                       const GURL& url,
+                                       const std::string& http_method,
+                                       bool is_initial_navigation,
+                                       bool is_server_redirect) {
+  return false;
+}
+
 void ContentRendererClient::WillSendRequest(blink::WebLocalFrame* frame,
                                             ui::PageTransition transition_type,
                                             const blink::WebURL& url,
diff --git a/content/public/renderer/content_renderer_client.h b/content/public/renderer/content_renderer_client.h
index 91baca2a078bcb5ed9d0874ec4af019298a05e18..b1468b42e882d2bd6b761d8a3db266b2a430b514 100644
--- a/content/public/renderer/content_renderer_client.h
+++ b/content/public/renderer/content_renderer_client.h
@@ -221,6 +221,13 @@ class CONTENT_EXPORT ContentRendererClient {
                                 bool is_redirect);
 #endif
 
+  // Returns true if we should fork a new process for the given navigation.
+  virtual bool ShouldFork(blink::WebLocalFrame* frame,
+                          const GURL& url,
+                          const std::string& http_method,
+                          bool is_initial_navigation,
+                          bool is_server_redirect);
+
   // Notifies the embedder that the given frame is requesting the resource at
   // |url|. If the function returns a valid |new_url|, the request must be
   // updated to use it. The |attach_same_site_cookies| output parameter
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 27a651c20cb2e84331b012fbf26b2a6c05b8ea6d..353973ef3b514b22c0c599b6c1c70c5eaaa59ff4 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -6028,6 +6028,15 @@ void RenderFrameImpl::BeginNavigation(
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
                        (cumulative_bindings & kWebUIBindingsPolicyMask);
+
+    if (!should_fork) {
+      // Give the embedder a chance.
+      bool is_initial_navigation = render_view_->history_list_length_ == 0;
+      should_fork = GetContentClient()->renderer()->ShouldFork(
+          frame_, url, info->url_request.HttpMethod().Utf8(),
+          is_initial_navigation, false /* is_redirect */);
+    }
+
     if (should_fork) {
       OpenURL(std::move(info));
       return;  // Suppress the load here.
diff --git a/content/renderer/render_view_browsertest.cc b/content/renderer/render_view_browsertest.cc
index 2e4920b0535a22e99d0593d5f41f4953453a29cb..8ebf2cb860f06adefae515981e66697aab708c78 100644
--- a/content/renderer/render_view_browsertest.cc
+++ b/content/renderer/render_view_browsertest.cc
@@ -989,6 +989,73 @@ TEST_F(RenderViewImplTest, BeginNavigationForWebUI) {
       FrameHostMsg_OpenURL::ID));
 }
 
+class AlwaysForkingRenderViewTest : public RenderViewImplTest {
+ public:
+  ContentRendererClient* CreateContentRendererClient() override {
+    return new TestContentRendererClient;
+  }
+
+ private:
+  class TestContentRendererClient : public ContentRendererClient {
+   public:
+    bool ShouldFork(blink::WebLocalFrame* frame,
+                    const GURL& url,
+                    const std::string& http_method,
+                    bool is_initial_navigation,
+                    bool is_server_redirect) override {
+      return true;
+    }
+  };
+};
+
+TEST_F(AlwaysForkingRenderViewTest, BeginNavigationDoesNotForkEmptyUrl) {
+  GURL example_url("http://example.com");
+  GURL empty_url("");
+
+  LoadHTMLWithUrlOverride("<body></body", example_url.spec().c_str());
+  EXPECT_EQ(example_url,
+            GURL(frame()->GetWebFrame()->GetDocumentLoader()->GetUrl()));
+
+  // Empty url should never fork.
+  blink::WebURLRequest request(empty_url);
+  request.SetMode(network::mojom::RequestMode::kNavigate);
+  request.SetRedirectMode(network::mojom::RedirectMode::kManual);
+  request.SetRequestContext(blink::mojom::RequestContextType::INTERNAL);
+  request.SetRequestorOrigin(blink::WebSecurityOrigin::Create(example_url));
+  auto navigation_info = std::make_unique<blink::WebNavigationInfo>();
+  navigation_info->url_request = request;
+  navigation_info->frame_type =
+      network::mojom::RequestContextFrameType::kTopLevel;
+  navigation_info->navigation_policy = blink::kWebNavigationPolicyCurrentTab;
+  frame()->BeginNavigation(std::move(navigation_info));
+  EXPECT_FALSE(render_thread_->sink().GetUniqueMessageMatching(
+      FrameHostMsg_OpenURL::ID));
+}
+
+TEST_F(AlwaysForkingRenderViewTest, BeginNavigationDoesNotForkAboutBlank) {
+  GURL example_url("http://example.com");
+  GURL blank_url(url::kAboutBlankURL);
+
+  LoadHTMLWithUrlOverride("<body></body", example_url.spec().c_str());
+  EXPECT_EQ(example_url,
+            GURL(frame()->GetWebFrame()->GetDocumentLoader()->GetUrl()));
+
+  // about:blank should never fork.
+  blink::WebURLRequest request(blank_url);
+  request.SetMode(network::mojom::RequestMode::kNavigate);
+  request.SetRedirectMode(network::mojom::RedirectMode::kManual);
+  request.SetRequestContext(blink::mojom::RequestContextType::INTERNAL);
+  request.SetRequestorOrigin(blink::WebSecurityOrigin::Create(example_url));
+  auto navigation_info = std::make_unique<blink::WebNavigationInfo>();
+  navigation_info->url_request = request;
+  navigation_info->frame_type =
+      network::mojom::RequestContextFrameType::kTopLevel;
+  navigation_info->navigation_policy = blink::kWebNavigationPolicyCurrentTab;
+  frame()->BeginNavigation(std::move(navigation_info));
+  EXPECT_FALSE(render_thread_->sink().GetUniqueMessageMatching(
+      FrameHostMsg_OpenURL::ID));
+}
+
 // This test verifies that when device emulation is enabled, RenderFrameProxy
 // continues to receive the original ScreenInfo and not the emualted
 // ScreenInfo.
